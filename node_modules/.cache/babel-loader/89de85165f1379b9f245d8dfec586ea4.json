{"ast":null,"code":"var __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nimport { useCallback, useMemo, useRef } from 'react';\n/**\n * Internal hook used to handle mutation middlewares.\n *\n * @example\n * // We have a form creating an order for a new customer.\n * // The form contains the customer fields in addition to the order fields\n * // but they should be saved as a new customer resource record\n * // and the order should only reference this new customer\n * type Order = { id: string; reference: string };\n * type OrderCreateFormData = { id: string; reference: string; customer: Customer };\n * type Customer = { id: string; email: string; firstName: string; lastName: string };\n *\n * const CustomerForm = props => {\n *     const [createCustomer] = useCreate<Customer>();\n *     const middleware: Middleware<UseCreateResult<OrderCreateFormData>[0]> = useCallback(async (resource, params, options, next) => {\n *         const { data } = params;\n *         const { user, ...orderData } = data;\n *         await createCustomer(\n *             'customers',\n *             { data: user },\n *             {\n *                 onSuccess: (newCustomer) => {\n *                     const orderDataWithCustomer = { ...orderData, customerId: newCustomer.id };\n *                     next(resource, { data: orderDataWithCustomer }, options);\n *                 },\n *             }\n *         });\n *     }, [createCustomer]);\n *     useRegisterMutationMiddleware(middleware);\n *\n *     return (\n *         <>\n *             <TextInput source=\"user.email\" />\n *             <TextInput source=\"user.firstName\" />\n *             <TextInput source=\"user.lastName\" />\n *         </>\n *     );\n * }\n */\n\nexport var useMutationMiddlewares = function () {\n  var callbacks = useRef([]);\n  var registerMutationMiddleware = useCallback(function (callback) {\n    callbacks.current.push(callback);\n  }, []);\n  var unregisterMutationMiddleware = useCallback(function (callback) {\n    callbacks.current = callbacks.current.filter(function (cb) {\n      return cb !== callback;\n    });\n  }, []);\n  var getMutateWithMiddlewares = useCallback(function (fn) {\n    return function () {\n      var _a;\n\n      var args = [];\n\n      for (var _i = 0; _i < arguments.length; _i++) {\n        args[_i] = arguments[_i];\n      }\n\n      var index = callbacks.current.length - 1; // Called by middlewares to call the next middleware function\n      // Should take the same arguments as the original mutation function\n\n      var next = function () {\n        var _a;\n\n        var newArgs = [];\n\n        for (var _i = 0; _i < arguments.length; _i++) {\n          newArgs[_i] = arguments[_i];\n        } // Decrement the middlewares counter so that when next is called again, we\n        // call the next middleware\n\n\n        index--; // If there are no more middlewares, we call the original mutation function\n\n        if (index >= 0) {\n          return (_a = callbacks.current)[index].apply(_a, __spreadArray(__spreadArray([], newArgs, false), [next], false));\n        } else {\n          return fn.apply(void 0, newArgs);\n        }\n      };\n\n      if (callbacks.current.length > 0) {\n        // Call the first middleware with the same args as the original mutation function\n        // with an additional next function\n        return (_a = callbacks.current)[index].apply(_a, __spreadArray(__spreadArray([], args, false), [next], false));\n      }\n\n      return fn.apply(void 0, args);\n    };\n  }, []);\n  var functions = useMemo(function () {\n    return {\n      registerMutationMiddleware: registerMutationMiddleware,\n      getMutateWithMiddlewares: getMutateWithMiddlewares,\n      unregisterMutationMiddleware: unregisterMutationMiddleware\n    };\n  }, [registerMutationMiddleware, getMutateWithMiddlewares, unregisterMutationMiddleware]);\n  return functions;\n};","map":{"version":3,"names":["__spreadArray","to","from","pack","arguments","length","i","l","ar","Array","prototype","slice","call","concat","useCallback","useMemo","useRef","useMutationMiddlewares","callbacks","registerMutationMiddleware","callback","current","push","unregisterMutationMiddleware","filter","cb","getMutateWithMiddlewares","fn","_a","args","_i","index","next","newArgs","apply","functions"],"sources":["/Users/evgenijgnedcik/Documents/GitHub/adminPixomnia/node_modules/ra-core/dist/esm/controller/saveContext/useMutationMiddlewares.js"],"sourcesContent":["var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { useCallback, useMemo, useRef } from 'react';\n/**\n * Internal hook used to handle mutation middlewares.\n *\n * @example\n * // We have a form creating an order for a new customer.\n * // The form contains the customer fields in addition to the order fields\n * // but they should be saved as a new customer resource record\n * // and the order should only reference this new customer\n * type Order = { id: string; reference: string };\n * type OrderCreateFormData = { id: string; reference: string; customer: Customer };\n * type Customer = { id: string; email: string; firstName: string; lastName: string };\n *\n * const CustomerForm = props => {\n *     const [createCustomer] = useCreate<Customer>();\n *     const middleware: Middleware<UseCreateResult<OrderCreateFormData>[0]> = useCallback(async (resource, params, options, next) => {\n *         const { data } = params;\n *         const { user, ...orderData } = data;\n *         await createCustomer(\n *             'customers',\n *             { data: user },\n *             {\n *                 onSuccess: (newCustomer) => {\n *                     const orderDataWithCustomer = { ...orderData, customerId: newCustomer.id };\n *                     next(resource, { data: orderDataWithCustomer }, options);\n *                 },\n *             }\n *         });\n *     }, [createCustomer]);\n *     useRegisterMutationMiddleware(middleware);\n *\n *     return (\n *         <>\n *             <TextInput source=\"user.email\" />\n *             <TextInput source=\"user.firstName\" />\n *             <TextInput source=\"user.lastName\" />\n *         </>\n *     );\n * }\n */\nexport var useMutationMiddlewares = function () {\n    var callbacks = useRef([]);\n    var registerMutationMiddleware = useCallback(function (callback) {\n        callbacks.current.push(callback);\n    }, []);\n    var unregisterMutationMiddleware = useCallback(function (callback) {\n        callbacks.current = callbacks.current.filter(function (cb) { return cb !== callback; });\n    }, []);\n    var getMutateWithMiddlewares = useCallback(function (fn) {\n        return function () {\n            var _a;\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            var index = callbacks.current.length - 1;\n            // Called by middlewares to call the next middleware function\n            // Should take the same arguments as the original mutation function\n            var next = function () {\n                var _a;\n                var newArgs = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    newArgs[_i] = arguments[_i];\n                }\n                // Decrement the middlewares counter so that when next is called again, we\n                // call the next middleware\n                index--;\n                // If there are no more middlewares, we call the original mutation function\n                if (index >= 0) {\n                    return (_a = callbacks.current)[index].apply(_a, __spreadArray(__spreadArray([], newArgs, false), [next], false));\n                }\n                else {\n                    return fn.apply(void 0, newArgs);\n                }\n            };\n            if (callbacks.current.length > 0) {\n                // Call the first middleware with the same args as the original mutation function\n                // with an additional next function\n                return (_a = callbacks.current)[index].apply(_a, __spreadArray(__spreadArray([], args, false), [next], false));\n            }\n            return fn.apply(void 0, args);\n        };\n    }, []);\n    var functions = useMemo(function () { return ({\n        registerMutationMiddleware: registerMutationMiddleware,\n        getMutateWithMiddlewares: getMutateWithMiddlewares,\n        unregisterMutationMiddleware: unregisterMutationMiddleware,\n    }); }, [\n        registerMutationMiddleware,\n        getMutateWithMiddlewares,\n        unregisterMutationMiddleware,\n    ]);\n    return functions;\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}