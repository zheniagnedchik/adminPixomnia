{"ast":null,"code":"var __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\nvar __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\n\nimport { useMemo } from 'react';\nimport { useQueryClient, useQuery, hashQueryKey } from 'react-query';\nimport union from 'lodash/union';\nimport { useDataProvider } from './useDataProvider';\n/**\n * Call the dataProvider.getMany() method and return the resolved result\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { isLoading: true, isFetching: true, refetch }\n * - success: { data: [data from response], isLoading: false, isFetching: false, refetch }\n * - error: { error: [error from response], isLoading: false, isFetching: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * This hook aggregates and deduplicates calls to the same resource, so for instance, if an app calls:\n *\n * useGetManyAggregate('tags', [1, 2, 3]);\n * useGetManyAggregate('tags', [3, 4]);\n *\n * during the same tick, the hook will only call the dataProvider once with the following parameters:\n *\n * dataProvider.getMany('tags', [1, 2, 3, 4])\n *\n * @param resource The resource name, e.g. 'posts'\n * @param {Params} params The getMany parameters { ids, meta }\n * @param {Object} options Options object to pass to the dataProvider.\n * @param {boolean} options.enabled Flag to conditionally run the query. If it's false, the query will not run\n * @param {Function} options.onSuccess Side effect function to be executed upon success, e.g. { onSuccess: { refresh: true } }\n * @param {Function} options.onError Side effect function to be executed upon failure, e.g. { onError: error => notify(error.message) }\n *\n * @typedef Params\n * @prop params.ids The ids to get, e.g. [123, 456, 789]\n * @prop params.meta Optional meta parameters\n\n * @returns The current request state. Destructure as { data, error, isLoading, isFetching, refetch }.\n *\n * @example\n *\n * import { useGetManyAggregate } from 'react-admin';\n *\n * const PostTags = ({ record }) => {\n *     const { data, isLoading, error } = useGetManyAggregate('tags', { ids: record.tagIds });\n *     if (isLoading) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return (\n *          <ul>\n *              {data.map(tag => (\n *                  <li key={tag.id}>{tag.name}</li>\n *              ))}\n *          </ul>\n *      );\n * };\n */\n\nexport var useGetManyAggregate = function (resource, params, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var dataProvider = useDataProvider();\n  var queryClient = useQueryClient();\n  var queryCache = queryClient.getQueryCache();\n  var ids = params.ids,\n      meta = params.meta;\n  var placeholderData = useMemo(function () {\n    var records = ids.map(function (id) {\n      var _a, _b;\n\n      var queryHash = hashQueryKey([resource, 'getOne', {\n        id: String(id),\n        meta: meta\n      }]);\n      return (_b = (_a = queryCache.get(queryHash)) === null || _a === void 0 ? void 0 : _a.state) === null || _b === void 0 ? void 0 : _b.data;\n    });\n\n    if (records.some(function (record) {\n      return record === undefined;\n    })) {\n      return undefined;\n    } else {\n      return records;\n    }\n  }, [ids, queryCache, resource, meta]);\n  return useQuery([resource, 'getMany', {\n    ids: ids.map(function (id) {\n      return String(id);\n    }),\n    meta: meta\n  }], function () {\n    return new Promise(function (resolve, reject) {\n      if (!ids || ids.length === 0) {\n        // no need to call the dataProvider\n        return resolve([]);\n      } // debounced / batched fetch\n\n\n      return callGetManyQueries({\n        resource: resource,\n        ids: ids,\n        meta: meta,\n        resolve: resolve,\n        reject: reject,\n        dataProvider: dataProvider,\n        queryClient: queryClient\n      });\n    });\n  }, __assign({\n    placeholderData: placeholderData,\n    onSuccess: function (data) {\n      // optimistically populate the getOne cache\n      data.forEach(function (record) {\n        queryClient.setQueryData([resource, 'getOne', {\n          id: String(record.id),\n          meta: meta\n        }], function (oldRecord) {\n          return oldRecord !== null && oldRecord !== void 0 ? oldRecord : record;\n        });\n      });\n    },\n    retry: false\n  }, options));\n};\n/**\n * Batch all calls to a function into one single call with the arguments of all the calls.\n *\n * @example\n * let sum = 0;\n * const add = (args) => { sum = args.reduce((arg, total) => total + arg, 0); };\n * const addBatched = batch(add);\n * addBatched(2);\n * addBatched(8);\n * // add will be called once with arguments [2, 8]\n * // and sum will be equal to 10\n */\n\nvar batch = function (fn) {\n  var capturedArgs = [];\n  var timeout = null;\n  return function (arg) {\n    capturedArgs.push(arg);\n    if (timeout) clearTimeout(timeout);\n    timeout = setTimeout(function () {\n      timeout = null;\n      fn(__spreadArray([], capturedArgs, true));\n      capturedArgs = [];\n    }, 0);\n  };\n};\n/**\n * Group and execute all calls to the dataProvider.getMany() method for the current tick\n *\n * Thanks to batch(), this function executes at most once per tick,\n * whatever the number of calls to useGetManyAggregate().\n */\n\n\nvar callGetManyQueries = batch(function (calls) {\n  var dataProvider = calls[0].dataProvider;\n  var queryClient = calls[0].queryClient;\n  /**\n   * Aggregate calls by resource\n   *\n   * callsByResource will look like:\n   * {\n   *     posts: [{ resource, ids, resolve, reject, dataProvider, queryClient }, ...],\n   *     tags: [{ resource, ids, resolve, reject, dataProvider, queryClient }, ...],\n   * }\n   */\n\n  var callsByResource = calls.reduce(function (acc, callArgs) {\n    if (!acc[callArgs.resource]) {\n      acc[callArgs.resource] = [];\n    }\n\n    acc[callArgs.resource].push(callArgs);\n    return acc;\n  }, {});\n  /**\n   * For each resource, aggregate ids and call dataProvider.getMany() once\n   */\n\n  Object.keys(callsByResource).forEach(function (resource) {\n    var callsForResource = callsByResource[resource];\n    /**\n     * Extract ids from queries, aggregate and deduplicate them\n     *\n     * @example from [[1, 2], [2, null, 3], [4, null]] to [1, 2, 3, 4]\n     */\n\n    var aggregatedIds = callsForResource.reduce(function (acc, _a) {\n      var ids = _a.ids;\n      return union(acc, ids);\n    }, []) // concat + unique\n    .filter(function (v) {\n      return v != null && v !== '';\n    }); // remove null values\n\n    var uniqueMeta = callsForResource.reduce(function (acc, _a) {\n      var meta = _a.meta;\n      return meta || acc;\n    }, undefined);\n\n    if (aggregatedIds.length === 0) {\n      // no need to call the data provider if all the ids are null\n      callsForResource.forEach(function (_a) {\n        var resolve = _a.resolve;\n        resolve([]);\n      });\n      return;\n    }\n\n    var callThatHasAllAggregatedIds = callsForResource.find(function (_a) {\n      var ids = _a.ids;\n      return JSON.stringify(ids) === JSON.stringify(aggregatedIds);\n    });\n\n    if (callThatHasAllAggregatedIds) {\n      // There is only one call (no aggregation), or one of the calls has the same ids as the sum of all calls.\n      // Either way, we can't trigger a new fetchQuery with the same signature, as it's already pending.\n      // Therefore, we reply with the dataProvider\n      var dataProvider_1 = callThatHasAllAggregatedIds.dataProvider,\n          resource_1 = callThatHasAllAggregatedIds.resource,\n          ids = callThatHasAllAggregatedIds.ids,\n          meta = callThatHasAllAggregatedIds.meta;\n      dataProvider_1.getMany(resource_1, {\n        ids: ids,\n        meta: meta\n      }).then(function (_a) {\n        var data = _a.data;\n        return data;\n      }).then(function (data) {\n        // We must then resolve all the pending calls with the data they requested\n        callsForResource.forEach(function (_a) {\n          var ids = _a.ids,\n              resolve = _a.resolve;\n          resolve(data.filter(function (record) {\n            return ids.map(function (id) {\n              return String(id);\n            }).includes(String(record.id));\n          }));\n        });\n      }, function (error) {\n        // All pending calls must also receive the error\n        callsForResource.forEach(function (_a) {\n          var reject = _a.reject;\n          reject(error);\n        });\n      });\n      return;\n    }\n    /**\n     * Call dataProvider.getMany() with the aggregatedIds,\n     * and resolve each of the promises using the results\n     */\n\n\n    queryClient.fetchQuery([resource, 'getMany', {\n      ids: aggregatedIds.map(function (id) {\n        return String(id);\n      }),\n      meta: uniqueMeta\n    }], function () {\n      return dataProvider.getMany(resource, {\n        ids: aggregatedIds,\n        meta: uniqueMeta\n      }).then(function (_a) {\n        var data = _a.data;\n        return data;\n      });\n    }).then(function (data) {\n      callsForResource.forEach(function (_a) {\n        var ids = _a.ids,\n            resolve = _a.resolve;\n        resolve(data.filter(function (record) {\n          return ids.map(function (id) {\n            return String(id);\n          }).includes(String(record.id));\n        }));\n      });\n    }).catch(function (error) {\n      return callsForResource.forEach(function (_a) {\n        var reject = _a.reject;\n        return reject(error);\n      });\n    });\n  });\n});","map":{"version":3,"names":["__assign","Object","assign","t","s","i","n","arguments","length","p","prototype","hasOwnProperty","call","apply","__spreadArray","to","from","pack","l","ar","Array","slice","concat","useMemo","useQueryClient","useQuery","hashQueryKey","union","useDataProvider","useGetManyAggregate","resource","params","options","dataProvider","queryClient","queryCache","getQueryCache","ids","meta","placeholderData","records","map","id","_a","_b","queryHash","String","get","state","data","some","record","undefined","Promise","resolve","reject","callGetManyQueries","onSuccess","forEach","setQueryData","oldRecord","retry","batch","fn","capturedArgs","timeout","arg","push","clearTimeout","setTimeout","calls","callsByResource","reduce","acc","callArgs","keys","callsForResource","aggregatedIds","filter","v","uniqueMeta","callThatHasAllAggregatedIds","find","JSON","stringify","dataProvider_1","resource_1","getMany","then","includes","error","fetchQuery","catch"],"sources":["/Users/evgenijgnedcik/Documents/GitHub/adminPixomnia/node_modules/ra-core/dist/esm/dataProvider/useGetManyAggregate.js"],"sourcesContent":["var __assign = (this && this.__assign) || function () {\n    __assign = Object.assign || function(t) {\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\n            s = arguments[i];\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))\n                t[p] = s[p];\n        }\n        return t;\n    };\n    return __assign.apply(this, arguments);\n};\nvar __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n        if (ar || !(i in from)) {\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n            ar[i] = from[i];\n        }\n    }\n    return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport { useMemo } from 'react';\nimport { useQueryClient, useQuery, hashQueryKey, } from 'react-query';\nimport union from 'lodash/union';\nimport { useDataProvider } from './useDataProvider';\n/**\n * Call the dataProvider.getMany() method and return the resolved result\n * as well as the loading state.\n *\n * The return value updates according to the request state:\n *\n * - start: { isLoading: true, isFetching: true, refetch }\n * - success: { data: [data from response], isLoading: false, isFetching: false, refetch }\n * - error: { error: [error from response], isLoading: false, isFetching: false, refetch }\n *\n * This hook will return the cached result when called a second time\n * with the same parameters, until the response arrives.\n *\n * This hook aggregates and deduplicates calls to the same resource, so for instance, if an app calls:\n *\n * useGetManyAggregate('tags', [1, 2, 3]);\n * useGetManyAggregate('tags', [3, 4]);\n *\n * during the same tick, the hook will only call the dataProvider once with the following parameters:\n *\n * dataProvider.getMany('tags', [1, 2, 3, 4])\n *\n * @param resource The resource name, e.g. 'posts'\n * @param {Params} params The getMany parameters { ids, meta }\n * @param {Object} options Options object to pass to the dataProvider.\n * @param {boolean} options.enabled Flag to conditionally run the query. If it's false, the query will not run\n * @param {Function} options.onSuccess Side effect function to be executed upon success, e.g. { onSuccess: { refresh: true } }\n * @param {Function} options.onError Side effect function to be executed upon failure, e.g. { onError: error => notify(error.message) }\n *\n * @typedef Params\n * @prop params.ids The ids to get, e.g. [123, 456, 789]\n * @prop params.meta Optional meta parameters\n\n * @returns The current request state. Destructure as { data, error, isLoading, isFetching, refetch }.\n *\n * @example\n *\n * import { useGetManyAggregate } from 'react-admin';\n *\n * const PostTags = ({ record }) => {\n *     const { data, isLoading, error } = useGetManyAggregate('tags', { ids: record.tagIds });\n *     if (isLoading) { return <Loading />; }\n *     if (error) { return <p>ERROR</p>; }\n *     return (\n *          <ul>\n *              {data.map(tag => (\n *                  <li key={tag.id}>{tag.name}</li>\n *              ))}\n *          </ul>\n *      );\n * };\n */\nexport var useGetManyAggregate = function (resource, params, options) {\n    if (options === void 0) { options = {}; }\n    var dataProvider = useDataProvider();\n    var queryClient = useQueryClient();\n    var queryCache = queryClient.getQueryCache();\n    var ids = params.ids, meta = params.meta;\n    var placeholderData = useMemo(function () {\n        var records = ids.map(function (id) {\n            var _a, _b;\n            var queryHash = hashQueryKey([\n                resource,\n                'getOne',\n                { id: String(id), meta: meta },\n            ]);\n            return (_b = (_a = queryCache.get(queryHash)) === null || _a === void 0 ? void 0 : _a.state) === null || _b === void 0 ? void 0 : _b.data;\n        });\n        if (records.some(function (record) { return record === undefined; })) {\n            return undefined;\n        }\n        else {\n            return records;\n        }\n    }, [ids, queryCache, resource, meta]);\n    return useQuery([resource, 'getMany', { ids: ids.map(function (id) { return String(id); }), meta: meta }], function () {\n        return new Promise(function (resolve, reject) {\n            if (!ids || ids.length === 0) {\n                // no need to call the dataProvider\n                return resolve([]);\n            }\n            // debounced / batched fetch\n            return callGetManyQueries({\n                resource: resource,\n                ids: ids,\n                meta: meta,\n                resolve: resolve,\n                reject: reject,\n                dataProvider: dataProvider,\n                queryClient: queryClient,\n            });\n        });\n    }, __assign({ placeholderData: placeholderData, onSuccess: function (data) {\n            // optimistically populate the getOne cache\n            data.forEach(function (record) {\n                queryClient.setQueryData([resource, 'getOne', { id: String(record.id), meta: meta }], function (oldRecord) { return oldRecord !== null && oldRecord !== void 0 ? oldRecord : record; });\n            });\n        }, retry: false }, options));\n};\n/**\n * Batch all calls to a function into one single call with the arguments of all the calls.\n *\n * @example\n * let sum = 0;\n * const add = (args) => { sum = args.reduce((arg, total) => total + arg, 0); };\n * const addBatched = batch(add);\n * addBatched(2);\n * addBatched(8);\n * // add will be called once with arguments [2, 8]\n * // and sum will be equal to 10\n */\nvar batch = function (fn) {\n    var capturedArgs = [];\n    var timeout = null;\n    return function (arg) {\n        capturedArgs.push(arg);\n        if (timeout)\n            clearTimeout(timeout);\n        timeout = setTimeout(function () {\n            timeout = null;\n            fn(__spreadArray([], capturedArgs, true));\n            capturedArgs = [];\n        }, 0);\n    };\n};\n/**\n * Group and execute all calls to the dataProvider.getMany() method for the current tick\n *\n * Thanks to batch(), this function executes at most once per tick,\n * whatever the number of calls to useGetManyAggregate().\n */\nvar callGetManyQueries = batch(function (calls) {\n    var dataProvider = calls[0].dataProvider;\n    var queryClient = calls[0].queryClient;\n    /**\n     * Aggregate calls by resource\n     *\n     * callsByResource will look like:\n     * {\n     *     posts: [{ resource, ids, resolve, reject, dataProvider, queryClient }, ...],\n     *     tags: [{ resource, ids, resolve, reject, dataProvider, queryClient }, ...],\n     * }\n     */\n    var callsByResource = calls.reduce(function (acc, callArgs) {\n        if (!acc[callArgs.resource]) {\n            acc[callArgs.resource] = [];\n        }\n        acc[callArgs.resource].push(callArgs);\n        return acc;\n    }, {});\n    /**\n     * For each resource, aggregate ids and call dataProvider.getMany() once\n     */\n    Object.keys(callsByResource).forEach(function (resource) {\n        var callsForResource = callsByResource[resource];\n        /**\n         * Extract ids from queries, aggregate and deduplicate them\n         *\n         * @example from [[1, 2], [2, null, 3], [4, null]] to [1, 2, 3, 4]\n         */\n        var aggregatedIds = callsForResource\n            .reduce(function (acc, _a) {\n            var ids = _a.ids;\n            return union(acc, ids);\n        }, []) // concat + unique\n            .filter(function (v) { return v != null && v !== ''; }); // remove null values\n        var uniqueMeta = callsForResource.reduce(function (acc, _a) {\n            var meta = _a.meta;\n            return meta || acc;\n        }, undefined);\n        if (aggregatedIds.length === 0) {\n            // no need to call the data provider if all the ids are null\n            callsForResource.forEach(function (_a) {\n                var resolve = _a.resolve;\n                resolve([]);\n            });\n            return;\n        }\n        var callThatHasAllAggregatedIds = callsForResource.find(function (_a) {\n            var ids = _a.ids;\n            return JSON.stringify(ids) === JSON.stringify(aggregatedIds);\n        });\n        if (callThatHasAllAggregatedIds) {\n            // There is only one call (no aggregation), or one of the calls has the same ids as the sum of all calls.\n            // Either way, we can't trigger a new fetchQuery with the same signature, as it's already pending.\n            // Therefore, we reply with the dataProvider\n            var dataProvider_1 = callThatHasAllAggregatedIds.dataProvider, resource_1 = callThatHasAllAggregatedIds.resource, ids = callThatHasAllAggregatedIds.ids, meta = callThatHasAllAggregatedIds.meta;\n            dataProvider_1\n                .getMany(resource_1, { ids: ids, meta: meta })\n                .then(function (_a) {\n                var data = _a.data;\n                return data;\n            })\n                .then(function (data) {\n                // We must then resolve all the pending calls with the data they requested\n                callsForResource.forEach(function (_a) {\n                    var ids = _a.ids, resolve = _a.resolve;\n                    resolve(data.filter(function (record) {\n                        return ids\n                            .map(function (id) { return String(id); })\n                            .includes(String(record.id));\n                    }));\n                });\n            }, function (error) {\n                // All pending calls must also receive the error\n                callsForResource.forEach(function (_a) {\n                    var reject = _a.reject;\n                    reject(error);\n                });\n            });\n            return;\n        }\n        /**\n         * Call dataProvider.getMany() with the aggregatedIds,\n         * and resolve each of the promises using the results\n         */\n        queryClient\n            .fetchQuery([\n            resource,\n            'getMany',\n            {\n                ids: aggregatedIds.map(function (id) { return String(id); }),\n                meta: uniqueMeta,\n            },\n        ], function () {\n            return dataProvider\n                .getMany(resource, {\n                ids: aggregatedIds,\n                meta: uniqueMeta,\n            })\n                .then(function (_a) {\n                var data = _a.data;\n                return data;\n            });\n        })\n            .then(function (data) {\n            callsForResource.forEach(function (_a) {\n                var ids = _a.ids, resolve = _a.resolve;\n                resolve(data.filter(function (record) {\n                    return ids\n                        .map(function (id) { return String(id); })\n                        .includes(String(record.id));\n                }));\n            });\n        })\n            .catch(function (error) {\n            return callsForResource.forEach(function (_a) {\n                var reject = _a.reject;\n                return reject(error);\n            });\n        });\n    });\n});\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}