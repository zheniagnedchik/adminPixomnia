{"ast":null,"code":"import { combineTransactionSteps, getChangedRanges, getMarksBetween, findChildrenInRange, getAttributes, Mark, mergeAttributes, markPasteRule } from '@tiptap/core';\nimport { test, find, registerCustomProtocol } from 'linkifyjs';\nimport { Plugin, PluginKey } from 'prosemirror-state';\n\nfunction autolink(options) {\n  return new Plugin({\n    key: new PluginKey('autolink'),\n    appendTransaction: (transactions, oldState, newState) => {\n      const docChanges = transactions.some(transaction => transaction.docChanged) && !oldState.doc.eq(newState.doc);\n      const preventAutolink = transactions.some(transaction => transaction.getMeta('preventAutolink'));\n\n      if (!docChanges || preventAutolink) {\n        return;\n      }\n\n      const {\n        tr\n      } = newState;\n      const transform = combineTransactionSteps(oldState.doc, [...transactions]);\n      const {\n        mapping\n      } = transform;\n      const changes = getChangedRanges(transform);\n      changes.forEach(_ref => {\n        let {\n          oldRange,\n          newRange\n        } = _ref;\n        // at first we check if we have to remove links\n        getMarksBetween(oldRange.from, oldRange.to, oldState.doc).filter(item => item.mark.type === options.type).forEach(oldMark => {\n          const newFrom = mapping.map(oldMark.from);\n          const newTo = mapping.map(oldMark.to);\n          const newMarks = getMarksBetween(newFrom, newTo, newState.doc).filter(item => item.mark.type === options.type);\n\n          if (!newMarks.length) {\n            return;\n          }\n\n          const newMark = newMarks[0];\n          const oldLinkText = oldState.doc.textBetween(oldMark.from, oldMark.to, undefined, ' ');\n          const newLinkText = newState.doc.textBetween(newMark.from, newMark.to, undefined, ' ');\n          const wasLink = test(oldLinkText);\n          const isLink = test(newLinkText); // remove only the link, if it was a link before too\n          // because we don’t want to remove links that were set manually\n\n          if (wasLink && !isLink) {\n            tr.removeMark(newMark.from, newMark.to, options.type);\n          }\n        }); // now let’s see if we can add new links\n\n        findChildrenInRange(newState.doc, newRange, node => node.isTextblock).forEach(textBlock => {\n          // we need to define a placeholder for leaf nodes\n          // so that the link position can be calculated correctly\n          const text = newState.doc.textBetween(textBlock.pos, textBlock.pos + textBlock.node.nodeSize, undefined, ' ');\n          find(text).filter(link => link.isLink).filter(link => {\n            if (options.validate) {\n              return options.validate(link.value);\n            }\n\n            return true;\n          }) // calculate link position\n          .map(link => ({ ...link,\n            from: textBlock.pos + link.start + 1,\n            to: textBlock.pos + link.end + 1\n          })) // check if link is within the changed range\n          .filter(link => {\n            const fromIsInRange = newRange.from >= link.from && newRange.from <= link.to;\n            const toIsInRange = newRange.to >= link.from && newRange.to <= link.to;\n            return fromIsInRange || toIsInRange;\n          }) // add link mark\n          .forEach(link => {\n            tr.addMark(link.from, link.to, options.type.create({\n              href: link.href\n            }));\n          });\n        });\n      });\n\n      if (!tr.steps.length) {\n        return;\n      }\n\n      return tr;\n    }\n  });\n}\n\nfunction clickHandler(options) {\n  return new Plugin({\n    key: new PluginKey('handleClickLink'),\n    props: {\n      handleClick: (view, pos, event) => {\n        var _a;\n\n        const attrs = getAttributes(view.state, options.type.name);\n        const link = (_a = event.target) === null || _a === void 0 ? void 0 : _a.closest('a');\n\n        if (link && attrs.href) {\n          window.open(attrs.href, attrs.target);\n          return true;\n        }\n\n        return false;\n      }\n    }\n  });\n}\n\nfunction pasteHandler(options) {\n  return new Plugin({\n    key: new PluginKey('handlePasteLink'),\n    props: {\n      handlePaste: (view, event, slice) => {\n        const {\n          state\n        } = view;\n        const {\n          selection\n        } = state;\n        const {\n          empty\n        } = selection;\n\n        if (empty) {\n          return false;\n        }\n\n        let textContent = '';\n        slice.content.forEach(node => {\n          textContent += node.textContent;\n        });\n        const link = find(textContent).find(item => item.isLink && item.value === textContent);\n\n        if (!textContent || !link) {\n          return false;\n        }\n\n        options.editor.commands.setMark(options.type, {\n          href: link.href\n        });\n        return true;\n      }\n    }\n  });\n}\n\nconst Link = Mark.create({\n  name: 'link',\n  priority: 1000,\n  keepOnSplit: false,\n\n  onCreate() {\n    this.options.protocols.forEach(registerCustomProtocol);\n  },\n\n  inclusive() {\n    return this.options.autolink;\n  },\n\n  addOptions() {\n    return {\n      openOnClick: true,\n      linkOnPaste: true,\n      autolink: true,\n      protocols: [],\n      HTMLAttributes: {\n        target: '_blank',\n        rel: 'noopener noreferrer nofollow',\n        class: null\n      },\n      validate: undefined\n    };\n  },\n\n  addAttributes() {\n    return {\n      href: {\n        default: null\n      },\n      target: {\n        default: this.options.HTMLAttributes.target\n      },\n      class: {\n        default: this.options.HTMLAttributes.class\n      }\n    };\n  },\n\n  parseHTML() {\n    return [{\n      tag: 'a[href]:not([href *= \"javascript:\" i])'\n    }];\n  },\n\n  renderHTML(_ref2) {\n    let {\n      HTMLAttributes\n    } = _ref2;\n    return ['a', mergeAttributes(this.options.HTMLAttributes, HTMLAttributes), 0];\n  },\n\n  addCommands() {\n    return {\n      setLink: attributes => _ref3 => {\n        let {\n          chain\n        } = _ref3;\n        return chain().setMark(this.name, attributes).setMeta('preventAutolink', true).run();\n      },\n      toggleLink: attributes => _ref4 => {\n        let {\n          chain\n        } = _ref4;\n        return chain().toggleMark(this.name, attributes, {\n          extendEmptyMarkRange: true\n        }).setMeta('preventAutolink', true).run();\n      },\n      unsetLink: () => _ref5 => {\n        let {\n          chain\n        } = _ref5;\n        return chain().unsetMark(this.name, {\n          extendEmptyMarkRange: true\n        }).setMeta('preventAutolink', true).run();\n      }\n    };\n  },\n\n  addPasteRules() {\n    return [markPasteRule({\n      find: text => find(text).filter(link => {\n        if (this.options.validate) {\n          return this.options.validate(link.value);\n        }\n\n        return true;\n      }).filter(link => link.isLink).map(link => ({\n        text: link.value,\n        index: link.start,\n        data: link\n      })),\n      type: this.type,\n      getAttributes: match => {\n        var _a;\n\n        return {\n          href: (_a = match.data) === null || _a === void 0 ? void 0 : _a.href\n        };\n      }\n    })];\n  },\n\n  addProseMirrorPlugins() {\n    const plugins = [];\n\n    if (this.options.autolink) {\n      plugins.push(autolink({\n        type: this.type,\n        validate: this.options.validate\n      }));\n    }\n\n    if (this.options.openOnClick) {\n      plugins.push(clickHandler({\n        type: this.type\n      }));\n    }\n\n    if (this.options.linkOnPaste) {\n      plugins.push(pasteHandler({\n        editor: this.editor,\n        type: this.type\n      }));\n    }\n\n    return plugins;\n  }\n\n});\nexport { Link, Link as default };","map":{"version":3,"mappings":"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","names":["autolink","options","Plugin","key","PluginKey","appendTransaction","transactions","oldState","newState","docChanges","some","transaction","docChanged","doc","eq","preventAutolink","getMeta","tr","transform","combineTransactionSteps","mapping","changes","getChangedRanges","forEach","oldRange","newRange","getMarksBetween","from","to","filter","item","mark","type","oldMark","newFrom","map","newTo","newMarks","length","newMark","oldLinkText","textBetween","undefined","newLinkText","wasLink","test","isLink","removeMark","findChildrenInRange","node","isTextblock","textBlock","text","pos","nodeSize","find","link","validate","value","start","end","fromIsInRange","toIsInRange","addMark","create","href","steps","clickHandler","props","handleClick","view","event","attrs","getAttributes","state","name","target","_a","closest","window","open","pasteHandler","handlePaste","slice","selection","empty","textContent","content","editor","commands","setMark","Mark","priority","keepOnSplit","onCreate","protocols","registerCustomProtocol","inclusive","addOptions","openOnClick","linkOnPaste","HTMLAttributes","rel","class","addAttributes","default","parseHTML","tag","renderHTML","mergeAttributes","addCommands","setLink","attributes","chain","setMeta","run","toggleLink","toggleMark","extendEmptyMarkRange","unsetLink","unsetMark","addPasteRules","markPasteRule","index","data","match","addProseMirrorPlugins","plugins","push"],"sources":["/Users/evgenijgnedcik/Documents/GitHub/adminPixomnia/node_modules/@tiptap/extension-link/src/helpers/autolink.ts","/Users/evgenijgnedcik/Documents/GitHub/adminPixomnia/node_modules/@tiptap/extension-link/src/helpers/clickHandler.ts","/Users/evgenijgnedcik/Documents/GitHub/adminPixomnia/node_modules/@tiptap/extension-link/src/helpers/pasteHandler.ts","/Users/evgenijgnedcik/Documents/GitHub/adminPixomnia/node_modules/@tiptap/extension-link/src/link.ts"],"sourcesContent":["import {\n  combineTransactionSteps,\n  findChildrenInRange,\n  getChangedRanges,\n  getMarksBetween,\n} from '@tiptap/core'\nimport { find, test } from 'linkifyjs'\nimport { MarkType } from 'prosemirror-model'\nimport { Plugin, PluginKey } from 'prosemirror-state'\n\ntype AutolinkOptions = {\n  type: MarkType,\n  validate?: (url: string) => boolean,\n}\n\nexport function autolink(options: AutolinkOptions): Plugin {\n  return new Plugin({\n    key: new PluginKey('autolink'),\n    appendTransaction: (transactions, oldState, newState) => {\n      const docChanges = transactions.some(transaction => transaction.docChanged)\n        && !oldState.doc.eq(newState.doc)\n      const preventAutolink = transactions.some(transaction => transaction.getMeta('preventAutolink'))\n\n      if (!docChanges || preventAutolink) {\n        return\n      }\n\n      const { tr } = newState\n      const transform = combineTransactionSteps(oldState.doc, [...transactions])\n      const { mapping } = transform\n      const changes = getChangedRanges(transform)\n\n      changes.forEach(({ oldRange, newRange }) => {\n        // at first we check if we have to remove links\n        getMarksBetween(oldRange.from, oldRange.to, oldState.doc)\n          .filter(item => item.mark.type === options.type)\n          .forEach(oldMark => {\n            const newFrom = mapping.map(oldMark.from)\n            const newTo = mapping.map(oldMark.to)\n            const newMarks = getMarksBetween(newFrom, newTo, newState.doc)\n              .filter(item => item.mark.type === options.type)\n\n            if (!newMarks.length) {\n              return\n            }\n\n            const newMark = newMarks[0]\n            const oldLinkText = oldState.doc.textBetween(oldMark.from, oldMark.to, undefined, ' ')\n            const newLinkText = newState.doc.textBetween(newMark.from, newMark.to, undefined, ' ')\n            const wasLink = test(oldLinkText)\n            const isLink = test(newLinkText)\n\n            // remove only the link, if it was a link before too\n            // because we don’t want to remove links that were set manually\n            if (wasLink && !isLink) {\n              tr.removeMark(newMark.from, newMark.to, options.type)\n            }\n          })\n\n        // now let’s see if we can add new links\n        findChildrenInRange(newState.doc, newRange, node => node.isTextblock)\n          .forEach(textBlock => {\n            // we need to define a placeholder for leaf nodes\n            // so that the link position can be calculated correctly\n            const text = newState.doc.textBetween(\n              textBlock.pos,\n              textBlock.pos + textBlock.node.nodeSize,\n              undefined,\n              ' ',\n            )\n\n            find(text)\n              .filter(link => link.isLink)\n              .filter(link => {\n                if (options.validate) {\n                  return options.validate(link.value)\n                }\n\n                return true\n              })\n              // calculate link position\n              .map(link => ({\n                ...link,\n                from: textBlock.pos + link.start + 1,\n                to: textBlock.pos + link.end + 1,\n              }))\n              // check if link is within the changed range\n              .filter(link => {\n                const fromIsInRange = newRange.from >= link.from && newRange.from <= link.to\n                const toIsInRange = newRange.to >= link.from && newRange.to <= link.to\n\n                return fromIsInRange || toIsInRange\n              })\n              // add link mark\n              .forEach(link => {\n                tr.addMark(link.from, link.to, options.type.create({\n                  href: link.href,\n                }))\n              })\n          })\n      })\n\n      if (!tr.steps.length) {\n        return\n      }\n\n      return tr\n    },\n  })\n}\n","import { getAttributes } from '@tiptap/core'\nimport { MarkType } from 'prosemirror-model'\nimport { Plugin, PluginKey } from 'prosemirror-state'\n\ntype ClickHandlerOptions = {\n  type: MarkType,\n}\n\nexport function clickHandler(options: ClickHandlerOptions): Plugin {\n  return new Plugin({\n    key: new PluginKey('handleClickLink'),\n    props: {\n      handleClick: (view, pos, event) => {\n        const attrs = getAttributes(view.state, options.type.name)\n        const link = (event.target as HTMLElement)?.closest('a')\n\n        if (link && attrs.href) {\n          window.open(attrs.href, attrs.target)\n\n          return true\n        }\n\n        return false\n      },\n    },\n  })\n}\n","import { Editor } from '@tiptap/core'\nimport { find } from 'linkifyjs'\nimport { MarkType } from 'prosemirror-model'\nimport { Plugin, PluginKey } from 'prosemirror-state'\n\ntype PasteHandlerOptions = {\n  editor: Editor,\n  type: MarkType,\n}\n\nexport function pasteHandler(options: PasteHandlerOptions): Plugin {\n  return new Plugin({\n    key: new PluginKey('handlePasteLink'),\n    props: {\n      handlePaste: (view, event, slice) => {\n        const { state } = view\n        const { selection } = state\n        const { empty } = selection\n\n        if (empty) {\n          return false\n        }\n\n        let textContent = ''\n\n        slice.content.forEach(node => {\n          textContent += node.textContent\n        })\n\n        const link = find(textContent).find(item => item.isLink && item.value === textContent)\n\n        if (!textContent || !link) {\n          return false\n        }\n\n        options.editor.commands.setMark(options.type, {\n          href: link.href,\n        })\n\n        return true\n      },\n    },\n  })\n}\n","import { Mark, markPasteRule, mergeAttributes } from '@tiptap/core'\nimport { find, registerCustomProtocol } from 'linkifyjs'\n\nimport { autolink } from './helpers/autolink'\nimport { clickHandler } from './helpers/clickHandler'\nimport { pasteHandler } from './helpers/pasteHandler'\n\nexport interface LinkOptions {\n  /**\n   * If enabled, it adds links as you type.\n   */\n  autolink: boolean,\n  /**\n   * An array of custom protocols to be registered with linkifyjs.\n   */\n  protocols: Array<string>,\n  /**\n   * If enabled, links will be opened on click.\n   */\n  openOnClick: boolean,\n  /**\n   * Adds a link to the current selection if the pasted content only contains an url.\n   */\n  linkOnPaste: boolean,\n  /**\n   * A list of HTML attributes to be rendered.\n   */\n  HTMLAttributes: Record<string, any>,\n  /**\n   * A validation function that modifies link verification for the auto linker.\n   * @param url - The url to be validated.\n   * @returns - True if the url is valid, false otherwise.\n   */\n  validate?: (url: string) => boolean,\n}\n\ndeclare module '@tiptap/core' {\n  interface Commands<ReturnType> {\n    link: {\n      /**\n       * Set a link mark\n       */\n      setLink: (attributes: { href: string, target?: string }) => ReturnType,\n      /**\n       * Toggle a link mark\n       */\n      toggleLink: (attributes: { href: string, target?: string }) => ReturnType,\n      /**\n       * Unset a link mark\n       */\n      unsetLink: () => ReturnType,\n    }\n  }\n}\n\nexport const Link = Mark.create<LinkOptions>({\n  name: 'link',\n\n  priority: 1000,\n\n  keepOnSplit: false,\n\n  onCreate() {\n    this.options.protocols.forEach(registerCustomProtocol)\n  },\n\n  inclusive() {\n    return this.options.autolink\n  },\n\n  addOptions() {\n    return {\n      openOnClick: true,\n      linkOnPaste: true,\n      autolink: true,\n      protocols: [],\n      HTMLAttributes: {\n        target: '_blank',\n        rel: 'noopener noreferrer nofollow',\n        class: null,\n      },\n      validate: undefined,\n    }\n  },\n\n  addAttributes() {\n    return {\n      href: {\n        default: null,\n      },\n      target: {\n        default: this.options.HTMLAttributes.target,\n      },\n      class: {\n        default: this.options.HTMLAttributes.class,\n      },\n    }\n  },\n\n  parseHTML() {\n    return [\n      { tag: 'a[href]:not([href *= \"javascript:\" i])' },\n    ]\n  },\n\n  renderHTML({ HTMLAttributes }) {\n    return [\n      'a',\n      mergeAttributes(this.options.HTMLAttributes, HTMLAttributes),\n      0,\n    ]\n  },\n\n  addCommands() {\n    return {\n      setLink: attributes => ({ chain }) => {\n        return chain()\n          .setMark(this.name, attributes)\n          .setMeta('preventAutolink', true)\n          .run()\n      },\n\n      toggleLink: attributes => ({ chain }) => {\n        return chain()\n          .toggleMark(this.name, attributes, { extendEmptyMarkRange: true })\n          .setMeta('preventAutolink', true)\n          .run()\n      },\n\n      unsetLink: () => ({ chain }) => {\n        return chain()\n          .unsetMark(this.name, { extendEmptyMarkRange: true })\n          .setMeta('preventAutolink', true)\n          .run()\n      },\n    }\n  },\n\n  addPasteRules() {\n    return [\n      markPasteRule({\n        find: text => find(text)\n          .filter(link => {\n            if (this.options.validate) {\n              return this.options.validate(link.value)\n            }\n\n            return true\n          })\n          .filter(link => link.isLink)\n          .map(link => ({\n            text: link.value,\n            index: link.start,\n            data: link,\n          })),\n        type: this.type,\n        getAttributes: match => ({\n          href: match.data?.href,\n        }),\n      }),\n    ]\n  },\n\n  addProseMirrorPlugins() {\n    const plugins = []\n\n    if (this.options.autolink) {\n      plugins.push(autolink({\n        type: this.type,\n        validate: this.options.validate,\n      }))\n    }\n\n    if (this.options.openOnClick) {\n      plugins.push(clickHandler({\n        type: this.type,\n      }))\n    }\n\n    if (this.options.linkOnPaste) {\n      plugins.push(pasteHandler({\n        editor: this.editor,\n        type: this.type,\n      }))\n    }\n\n    return plugins\n  },\n})\n"]},"metadata":{},"sourceType":"module"}